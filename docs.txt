=== D&D GM ASSIST TOOL - PROJECT DOCUMENTATION ===

## OVERVIEW
DND-like assist tool for GM and players. Custom ruleset. Core principle: every page view auto-creates via URL and syncs in real-time.

## STACK
Frontend: Angular 21 (standalone, signals) | Backend: NestJS 11 | Real-time: Socket.IO 4.8 | Storage: JSON files

## ARCHITECTURE
- Client patches state locally (optimistic UI) → sends patch via WebSocket
- Server applies patch to JSON file → broadcasts to all room members
- Custom JSON patch: {path: "inventory.0.name", value: "Sword"}
- Path uses dot notation, supports array indexing

## DATA STORAGE
- backend/data.json: {characterId: JSON.stringify(CharacterSheet)}
- backend/worlds.json: {worldName: JSON.stringify(WorldData)}
- Atomic file writes, no database

## ROUTING
/characters/:id → SheetComponent (player view) - auto-creates if missing
/world/:worldName → WorldComponent (GM dashboard) - auto-creates if missing
/game/:id → SessionComponent (placeholder)

## SHEET VIEW (Player Features)
- Character attributes (name, race, class, age, alignment)
- Stats: Strength, Dexterity, Speed, Intelligence, Chill, Constitution (base/gain/bonus/current)
- Status: Leben (Life), Ausdauer (Stamina), Mana
- Inventory/Equipment with weight, requirements
- Skills, Runes, Spells (create/edit UI)
- Currency: copper, silver, gold, platinum
- Battle turn tracker with visual indicators
- Loot popup system (receives items during battle)
- Portrait upload (base64)
- Action Macro System (visual action scripting)

## WORLD VIEW (GM Features)
- Character library CRUD
- Party management (add/remove members)
- Item/Rune/Spell/Skill libraries (world-scoped)
- Drag-drop loot distribution to party
- Battle tracker: turn order, team grouping, participant add/remove
- Battle controls: advance turn, reset, reveal loot
- Loot bundles (predefined reward packages)
- Real-time character sheet monitoring

## WEBSOCKET EVENTS
joinCharacter, patchCharacter, characterPatched
joinWorld, patchWorld, worldPatched
claimBattleLoot, battleLootReceived, revealBattleLoot
sendDirectLoot, lootReceived

## KEY FILES
Backend:
- main.ts: Bootstrap (port 3000, CORS)
- app.module.ts: Module config, serves frontend
- app.controller.ts: REST API (GET/POST/PATCH)
- data.service.ts: File I/O, patch logic
- character.gateway.ts: Character WebSocket
- world.gateway.ts: World WebSocket, loot distribution

Frontend Services:
- character-socket.service.ts: Socket.IO for characters
- character-store.service.ts: State + patch application
- character-api.service.ts: HTTP endpoints
- world-socket.service.ts: Socket.IO for worlds
- world-store.service.ts: World state + migrations
- world-api.service.ts: World HTTP endpoints
- weapon-generator.service.ts: Procedural generation

Frontend Models:
- character-sheet-model.ts: CharacterSheet interface
- world.model.ts: WorldData, LootItem, BattleParticipant
- stat-block.model.ts: StatBlock (base/gain/bonus/current)
- json-patch.model.ts: {path, value}
- item-block, spell-block, rune-block, skill-block models

Frontend Components:
- sheet.component.ts: Player view
- world/world.component.ts: GM view
- session.component.ts: Empty placeholder

## API ROUTES
GET /api/characters/:id - Load sheet (null if missing)
POST /api/characters/:id - Save full sheet
PATCH /api/characters/:id - Apply patch
POST /api/characters/:id/portrait - Upload portrait
GET /api/worlds/:name - Load world
POST /api/worlds/:name - Save world
PATCH /api/worlds/:name - Apply patch

## DESIGN PRINCIPLES
1. URL creates objects on-the-fly (convenience-first)
2. Real-time sync always via WebSockets
3  State should always persist and be stored.
4. Optimistic UI (client patches before server confirm)
5. Simple custom JSON patch (dot-path, not RFC 6902)
6. World-scoped libraries (items/runes/spells/skills)
7. Battle system: turn order, teams, loot distribution

## ACTION MACRO SYSTEM
Visual scripting system for creating complex character actions without coding.

### FEATURES
- Condition-based execution (check resources, stats, skills)
- Multiple consequence types: dice rolls, resource changes
- Unified dice configuration across all action types
- Advanced formula parser: supports XdY±Z, XdY*Z, XdY/Z, complex combinations
- Visual validation: formulas glow green/red based on syntax correctness
- Custom naming and color-coding for each roll
- Saved dice configurations can be referenced
- Results display merged (rolls + resource changes in one section)

### ARCHITECTURE
- Model: action-macro.model.ts (ActionMacro, ActionCondition, ActionConsequence)
- Component: action-macros.component.ts
- Template: action-macros.component.html (fullscreen overlay editor)
- Styling: action-macros.component.css (dark theme, card-based UI)

### CONDITION TYPES
- resource: Compare current resource (health/energy/mana) to value/resource/stat
- stat: Compare stat (strength/dexterity/etc) to value/resource/stat
- skill: Check if character has specific skill

### CONSEQUENCE TYPES
- dice_roll: Roll dice with formula (displays result)
- spend_resource: Deduct resource (can use dice formula for variable cost)
- gain_resource: Add resource (can use dice formula for variable gain)

### FORMULA SYNTAX
Supports: 1d20+5, 2d6+3, 3d10*2, 1d8+2-1, 10 (fixed value)
Parser validates: dice count (1-100), dice type (2-1000), division by zero
Operations: +, -, *, / with proper precedence

### UI COMPONENTS
- Card-based consequence editor with unified dice config
- Real-time formula validation with visual feedback
- Color picker and name fields for roll identification
- Merged results display (rolls + resource changes)
- Drag-and-drop macro reordering
- Icon and color customization for actions

### STORAGE
- Stored in localStorage: actionMacros-{characterId}
- Auto-validates against character skill list
- Invalid macros (missing skills) are marked but preserved



The Battletracker is basically a queue of tiles that indicate the next turn of a character in combat.

The Battletracker should.
Calculate the turn order places of all tiles using speed of the characters the tiles belong to. More speed = more turns!
When a tile is dragged, everything to the left of it (including it) will turn into a scripted "area" where speed no longer matters. 
The turnorder is fixed at that part. 
The rightside of the scripted turns is still calculated based on the speed of the characters.
If nothing is dragged everything is based on speed.

Pressing next turn should consume a tile or "grouped turn" having everything move from left to right. 

Group turns. When two teammates are next to eachother they should be grouped into a single turn. 
A character cannot be grouped with himself.

Animations:

When tiles move to a new place they should just slide left or right depending on where they go.
If a new tile appears it should fade in from the top
If a tile is removed it should fade out on the bottom.
This means that pressing next everything should just slide to the left visually. 










