=== D&D GM ASSIST TOOL - PROJECT DOCUMENTATION ===

## OVERVIEW
DND-like assist tool for GM and players. Custom ruleset. Core principle: every page view auto-creates via URL and syncs in real-time.

## STACK
Frontend: Angular 21 (standalone, signals) | Backend: NestJS 11 | Real-time: Socket.IO 4.8 | Storage: JSON files

## ARCHITECTURE
- Client patches state locally (optimistic UI) → sends patch via WebSocket
- Server applies patch to JSON file → broadcasts to all room members
- Custom JSON patch: {path: "inventory.0.name", value: "Sword"}
- Path uses dot notation, supports array indexing

## DATA STORAGE
**NEW DIRECTORY-BASED STRUCTURE (Feb 2026):**

### Philosophy
- Entity-based file organization: Each logical entity gets its own file
- Human-readable structure: Easy to inspect, backup, and manage
- URL-driven identity: File names based on URL identifiers, not internal data
- No monolithic JSON: No large files with nested arrays

### Storage Layout
```
data/
  characters/
    {characterId}.json           # e.g., abc123.json, def456.json
    
  worlds/
    {worldName}/                 # e.g., test/, testWorld/
      world.json                 # Core world data (name, characterIds, partyIds, battleLoot, etc.)
      lobby.json                 # Lobby configuration  
      items/
        {itemId}.json            # Individual item files
      spells/
        {spellId}.json           # Individual spell files
      runes/
        {runeId}.json            # Individual rune files
      skills/
        {skillId}.json           # Individual skill files
      loot-bundles/
        {bundleId}.json          # Individual loot bundle files
      maps/
        {mapId}/                 # Each map gets its own folder
          map.json               # Map data (tokens, images, strokes, etc.)
          
  races/
    {raceId}.json                # e.g., race_123.json, race_456.json

  textures.json                  # Global texture library
  textures/                      # Texture image files
  images/                        # Character/entity images
```

### Key Principles
1. **Characters are global**: Not tied to a specific world, can be in multiple worlds
2. **URL determines filename**: /characters/abc → abc.json, /world/testWorld → worlds/testWorld/
3. **Name field irrelevant**: Character/world name inside JSON doesn't affect filename
4. **Atomic file operations**: Each entity saved independently
5. **Easy backup/delete**: Copy/remove individual files or entire world folders

**IMPORTANT - LOCAL vs SERVER DATA:**
- Local repository data is for DEVELOPMENT/TESTING only
- Real production data lives ONLY on the deployed server
- Local characters/, worlds/, races/ folders should be kept empty in git
- Do not confuse local test data with actual server data

## ROUTING
/characters/:id → SheetComponent (player view) - auto-creates if missing
/world/:worldName → WorldComponent (GM dashboard) - auto-creates if missing
/lobby/:worldName → LobbyComponent (tactical map) - linked to world
/game/:id → SessionComponent (placeholder)

## SHEET VIEW (Player Features)
- Character attributes (name, race, class, age, alignment)
- Stats: Strength, Dexterity, Speed, Intelligence, Chill, Constitution (base/gain/bonus/current)
- Status: Leben (Life), Ausdauer (Stamina), Mana
- Inventory/Equipment with weight, requirements
- Skills, Runes, Spells (create/edit UI)
- Currency: copper, silver, gold, platinum
- Battle turn tracker with visual indicators
- Loot popup system (receives items during battle)
- Portrait upload (base64)
- Action Macro System (visual action scripting)

## WORLD VIEW (GM Features)
- Character library CRUD
- Party management (add/remove members)
- Item/Rune/Spell/Skill libraries (world-scoped)
- Drag-drop loot distribution to party
- Battle tracker: turn order, team grouping, participant add/remove
- Battle controls: advance turn, reset, reveal loot
- Loot bundles (predefined reward packages)
- Real-time character sheet monitoring

## WEBSOCKET EVENTS
joinCharacter, patchCharacter, characterPatched
joinWorld, patchWorld, worldPatched
claimBattleLoot, battleLootReceived, revealBattleLoot
sendDirectLoot, lootReceived

## KEY FILES
Backend:
- main.ts: Bootstrap (port 3000, CORS)
- app.module.ts: Module config, serves frontend
- app.controller.ts: REST API (GET/POST/PATCH)
- data.service.ts: File I/O, patch logic
- character.gateway.ts: Character WebSocket
- world.gateway.ts: World WebSocket, loot distribution

Frontend Services:
- character-socket.service.ts: Socket.IO for characters
- character-store.service.ts: State + patch application
- character-api.service.ts: HTTP endpoints
- world-socket.service.ts: Socket.IO for worlds
- world-store.service.ts: World state + migrations
- world-api.service.ts: World HTTP endpoints
- lobby-socket.service.ts: Socket.IO for lobby real-time sync
- lobby-store.service.ts: Lobby state management
- lobby-api.service.ts: Lobby HTTP endpoints
- weapon-generator.service.ts: Procedural generation

Frontend Models:
- character-sheet-model.ts: CharacterSheet interface
- world.model.ts: WorldData, LootItem, BattleParticipant
- lobby.model.ts: LobbyData, LobbyMap, MapToken, MapImage, MapStroke, HexMath
- stat-block.model.ts: StatBlock (base/gain/bonus/current)
- json-patch.model.ts: {path, value}
- item-block, spell-block, rune-block, skill-block models

Frontend Components:
- sheet.component.ts: Player view
- world/world.component.ts: GM view
- lobby/lobby.component.ts: Tactical map view
- session.component.ts: Empty placeholder

## API ROUTES
GET /api/characters/:id - Load sheet (null if missing)
POST /api/characters/:id - Save full sheet
PATCH /api/characters/:id - Apply patch
POST /api/characters/:id/portrait - Upload portrait
GET /api/worlds/:name - Load world
POST /api/worlds/:name - Save world
PATCH /api/worlds/:name - Apply patch
GET /api/lobby/:worldName - Load lobby for world
POST /api/lobby/:worldName - Save lobby for world
GET /api/images/:id - Get image data
POST /api/images - Upload image

## DESIGN PRINCIPLES
1. URL creates objects on-the-fly (convenience-first)
2. Real-time sync always via WebSockets
3  State should always persist and be stored.
4. Optimistic UI (client patches before server confirm)
5. Simple custom JSON patch (dot-path, not RFC 6902)
6. World-scoped libraries (items/runes/spells/skills)
7. Battle system: turn order, teams, loot distribution

## ACTION MACRO SYSTEM
Visual scripting system for creating complex character actions without coding.

### FEATURES
- Condition-based execution (check resources, stats, skills)
- Multiple consequence types: dice rolls, resource changes
- Unified dice configuration across all action types
- Advanced formula parser: supports XdY±Z, XdY*Z, XdY/Z, complex combinations
- Visual validation: formulas glow green/red based on syntax correctness
- Custom naming and color-coding for each roll
- Saved dice configurations can be referenced
- Results display merged (rolls + resource changes in one section)

### ARCHITECTURE
- Model: action-macro.model.ts (ActionMacro, ActionCondition, ActionConsequence)
- Component: action-macros.component.ts
- Template: action-macros.component.html (fullscreen overlay editor)
- Styling: action-macros.component.css (dark theme, card-based UI)

### CONDITION TYPES
- resource: Compare current resource (health/energy/mana) to value/resource/stat
- stat: Compare stat (strength/dexterity/etc) to value/resource/stat
- skill: Check if character has specific skill

### CONSEQUENCE TYPES
- dice_roll: Roll dice with formula (displays result)
- spend_resource: Deduct resource (can use dice formula for variable cost)
- gain_resource: Add resource (can use dice formula for variable gain)

### FORMULA SYNTAX
Supports: 1d20+5, 2d6+3, 3d10*2, 1d8+2-1, 10 (fixed value)
Parser validates: dice count (1-100), dice type (2-1000), division by zero
Operations: +, -, *, / with proper precedence

### UI COMPONENTS
- Card-based consequence editor with unified dice config
- Real-time formula validation with visual feedback
- Color picker and name fields for roll identification
- Merged results display (rolls + resource changes)
- Drag-and-drop macro reordering
- Icon and color customization for actions

### STORAGE
- Stored in localStorage: actionMacros-{characterId}
- Auto-validates against character skill list
- Invalid macros (missing skills) are marked but preserved



## BATTLE TRACKER (Turn Meter Simulation System)
The Battle Tracker manages turn order in combat using a turn meter simulation system.

### CORE CONCEPT
- Each character has a turn meter ranging from 0 to 1000
- Every simulation tick, each character's speed is added to their turn meter
- When a character reaches >= 1000, they get a turn tile and their meter resets to (meter - 1000), keeping overshoot
- If multiple characters reach 1000 in the same tick, the one with higher speed goes first
- The system simulates until it has 15 tiles in the timeline

### KEY PROPERTIES
- Timeline is purely calculated from current turn meters + speeds
- No manual dragging - everything is deterministic based on stats
- "Next Turn" advances the actual turn meters to the next state where a different tile would be first

### TURN METER CONTROLS (World View Only)
- Slider for each character in battle showing their current turn meter (0-999)
- GM can adjust turn meters directly to manipulate turn order
- "Reset Meters" button sets all turn meters to 0

### GROUPING
- Adjacent tiles of the same team (but different characters) are grouped together
- Groups are visually connected and treated as a single turn
- A character cannot be grouped with themselves

### ANIMATIONS
- FLIP animations for smooth tile movement
- New tiles slide in from the top
- Tiles slide left/right to new positions smoothly

### ARCHITECTURE
- battle-tracker-engine.ts: Core simulation engine with turn meter logic
- battle-tracker.component.ts: UI component with animations
- World view: Full controls including turn meter sliders
- Lobby view: Read-only view that syncs via WebSocket

### DATA PERSISTENCE
Turn meter state is stored in world.battleParticipants:
- turnFrequency field stores the current turn meter value (0-999)
- team field stores the team color
- speed field stores the character's speed stat 


## LOBBY SYSTEM (Tactical Map)
The Lobby is the tactical hex-grid map system for running encounters. Renamed from "battlemap" for clarity.

### ARCHITECTURE
Clean separation of concerns:
- lobby.model.ts: All type definitions, HexMath utility class
- lobby-store.service.ts: BehaviorSubject state management
- lobby-api.service.ts: HTTP persistence
- lobby-socket.service.ts: Real-time WebSocket sync

### DATA MODEL
LobbyData: Top-level container for a world's tactical maps
- worldName: string (links to WorldData)
- maps: LobbyMap[] (multiple maps per world)
- activeMapId: string

LobbyMap: Individual tactical map
- id, name, gridType ('hex' | 'square')
- tokens: MapToken[] (character tokens on grid)
- images: MapImage[] (background images)
- strokes: MapStroke[] (drawings)
- walls: HexCoord[][] (blocked paths)
- fogOfWar: HexCoord[] (hidden hexes)

MapToken: Character token on grid
- id, characterId, position (HexCoord)
- size (1-4 hexes), team ('party' | 'enemy' | 'neutral')

MapImage: Background image layer
- id, imageId (references /api/images/:id)
- position (x, y pixels), scale, rotation, zIndex

MapStroke: Freehand drawing
- id, points[], color, width

### HexMath UTILITY CLASS
Static methods for hexagon calculations (pointy-top hexagons):
- hexToPixel(hex, size): Convert hex coord to pixel center
- pixelToHex(x, y, size): Convert pixel to nearest hex
- getHexCorners(center, size): Get 6 corner points for drawing
- hexDistance(a, b): Manhattan distance in hex space
- hexNeighbors(hex): Get 6 adjacent hexes
- findPath(start, goal, isBlocked): A* pathfinding

### CANVAS RENDERING
Four-layer canvas system for performance:
1. gridCanvas: Hex grid lines (static, only redraws on pan/zoom)
2. imageCanvas: Background images (sorted by zIndex)
3. drawCanvas: Freehand strokes
4. overlayCanvas: Tokens, selection, UI elements

Performance optimizations:
- requestAnimationFrame batching
- Simplified rendering when zoomed out
- Layer separation (only redraw affected layer)
- Image caching to prevent reload flicker

### COMPONENTS
- lobby.component.ts: Main container, route handling, tool state
- lobby-grid.component.ts: Canvas rendering, mouse/touch interactions
- lobby-toolbar.component.ts: Tool selection (cursor, draw, erase, walls, measure, image)
- lobby-sidebar.component.ts: Tabbed panel (Characters | Images)
- lobby-token.component.ts: Individual token display with drag events

### TOOLS
- cursor: Select/move tokens, select/transform images
- draw: Freehand drawing on draw layer
- erase: Remove strokes
- walls: Toggle wall segments between hexes
- measure: Distance calculation between hexes
- image: Add images from library to map

### IMAGE HANDLING
Images stored server-side via ImageService:
- POST /api/images: Upload new image, returns imageId
- GET /api/images/:id: Retrieve image data
- Images referenced by ID in MapImage (prevents large data in socket messages)

Image transforms:
- Scale: Drag corner handles
- Rotate: Drag rotation handle
- Position: Drag image body
- Z-Index: Right-click context menu (to front/back, forward/backward)

### WEBSOCKET EVENTS
joinLobby, leaveLobby
patchLobby, lobbyPatched
addToken, moveToken, removeToken
addImage, updateImage, removeImage
addStroke, removeStroke
toggleWall, updateFog










